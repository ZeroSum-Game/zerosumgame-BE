require("dotenv").config();
const express=require("express");
const http=require("http");
const {Server}=require("socket.io");
const {PrismaClient}=require("@prisma/client");
const cors=require("cors");
const path=require("path");
const passport=require("passport");
const GoogleStrategy=require("passport-google-oauth20").Strategy;
const session=require("express-session");
if(process.platform==="win32"){try{process.stdout.setDefaultEncoding("utf8");process.stderr.setDefaultEncoding("utf8");}catch(e){}}
BigInt.prototype.toJSON=function(){return this.toString();};
const app=express();
const server=http.createServer(app);
let io;
const prisma=new PrismaClient();
const sessionMiddleware=session({secret:process.env.SESSION_SECRET||"secret",resave:false,saveUninitialized:true});
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname,"public")));
app.use(sessionMiddleware);
app.use(passport.initialize());
app.use(passport.session());
passport.serializeUser((user,done)=>done(null,user));
passport.deserializeUser((obj,done)=>done(null,obj));
passport.use(new GoogleStrategy({clientID:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,callbackURL:"/api/auth/google/callback"},async(accessToken,refreshToken,profile,done)=>{try{const googleId=profile.id;const email=profile.emails?.[0]?.value;const displayName=profile.displayName;if(!googleId||!email||!displayName)return done(new Error("Missing required Google profile fields"));const user=await prisma.user.upsert({where:{googleId},update:{email,nickname:displayName},create:{googleId,email,nickname:displayName,totalWins:0,totalGames:0}});return done(null,user);}catch(err){return done(err);}}));
const INITIAL_CASH=3000000n;
const MUSK_BONUS=1000000n;
const LEE_START_SAMSUNG_SHARES=10;
const TRUMP_TOLL_BONUS_RATE=0.05;
const PUTIN_WAR_BONUS=10;
const WAR_BASE_RATE=30;
const WAR_RATIO_RATE=40;
const WAR_BASE_MIN=30;
const WAR_BASE_MAX=70;
const WAR_FINAL_MIN=25;
const WAR_FINAL_MAX=80;
const WORLD_CUP_COST=800000n;
const LANDMARK_RATE_NUM=2n;
const LANDMARK_RATE_DEN=5n;
const TAKEOVER_RATE_NUM=3n;
const TAKEOVER_RATE_DEN=2n;
const SELL_RATE_NUM=7n;
const SELL_RATE_DEN=10n;
const MARKET_SYMBOLS={SAMSUNG:{key:"samsung",priceField:"priceSamsung",prevField:"prevSamsung"},TESLA:{key:"tesla",priceField:"priceTesla",prevField:"prevTesla"},LOCKHEED:{key:"lockheed",priceField:"priceLockheed",prevField:"prevLockheed"},GOLD:{key:"gold",priceField:"priceGold",prevField:"prevGold"},BITCOIN:{key:"bitcoin",priceField:"priceBtc",prevField:"prevBtc"}};
const MARKET_DEFAULTS={priceSamsung:100000n,priceTesla:500000n,priceLockheed:800000n,priceGold:200000n,priceBtc:5000000n,prevSamsung:100000n,prevTesla:500000n,prevLockheed:800000n,prevGold:200000n,prevBtc:5000000n};
const LAND_PRICE_BY_NODE={1:535500n,3:665000n,5:756000n,6:735000n,7:700000n,10:770000n,11:630000n,13:567000n,15:598500n,17:661500n,19:1001000n,21:770000n,22:924000n,23:885000n,26:630000n,27:567000n,29:735000n,31:1078000n};
const LAND_STABILITY_BY_NODE={1:0.9,3:1.0,5:0.9,6:1.0,7:1.0,10:1.0,11:0.9,13:0.9,15:0.9,17:0.9,19:1.1,21:1.0,22:1.1,23:1.1,26:0.9,27:0.9,29:1.0,31:1.1};
const LAND_TOLL_BY_NODE={1:85000n,3:95000n,5:120000n,6:105000n,7:100000n,10:110000n,11:100000n,13:90000n,15:95000n,17:105000n,19:130000n,21:110000n,22:120000n,23:115000n,26:100000n,27:90000n,29:105000n,31:140000n};
const STOCK_WAR_WEIGHT={stock:0.8,gold:1.0,bitcoin:0.6};
const CHARACTER_LABEL={MUSK:"MUSK",LEE:"LEE",TRUMP:"TRUMP",PUTIN:"PUTIN"};
const WAR_LINE_RANGES=[{name:"ASIA",start:0,end:7},{name:"EUROPE",start:8,end:15},{name:"AFRICA",start:16,end:23},{name:"AMERICA",start:24,end:31}];
const NEUTRAL_NODES=new Set([0,3,12,16,20,24,28,30]);
const warState={active:false,warLine:null,warNode:null,turnsLeft:0,recoveryActive:false,recoveryLine:1,recoveryNode:1};
const lobbyStateByRoom=new Map();
const socketUserMap=new Map();
const roomTurnOrder=new Map();
const currentTurnUserByRoom=new Map();
const tradeLockByRoom=new Map();
const turnStateByRoom=new Map();
const actionWindowByRoom=new Map();
const lastCardByRoom=new Map();
function normalizeSymbol(symbol){if(!symbol)return null;const key=String(symbol).trim().toUpperCase();return MARKET_SYMBOLS[key]?key:null;}
function randomizePrice(basePrice){const delta=(Math.random()*0.2)-0.1;const next=Math.max(1,Math.round(Number(basePrice)*(1+delta)));return BigInt(next);}
async function getOrCreateMarket(tx,roomId){return tx.market.upsert({where:{roomId},update:{},create:{roomId,...MARKET_DEFAULTS}});}
async function resetMarketDefaults(tx,roomId){return tx.market.upsert({where:{roomId},update:{...MARKET_DEFAULTS},create:{roomId,...MARKET_DEFAULTS}});}
async function getLatestPlayersByUser(tx,roomId){const players=await tx.player.findMany({where:{roomId},orderBy:{id:"desc"}});const byUser=new Map();for(const p of players){if(!byUser.has(p.userId))byUser.set(p.userId,p);}return Array.from(byUser.values());}
async function getTurnPlayerId(tx,roomId){const room=await tx.room.findUnique({where:{id:roomId}});if(!room)return null;const players=await getLatestPlayersByUser(tx,roomId);if(players.length===0)return null;const turnOrder=roomTurnOrder.get(roomId);if(turnOrder&&turnOrder.length){const playerSet=new Set(players.map((p)=>p.id));const filtered=turnOrder.filter((id)=>playerSet.has(id));if(filtered.length){roomTurnOrder.set(roomId,filtered);return filtered[room.turnPlayerIdx%filtered.length];}roomTurnOrder.delete(roomId);}const sorted=players.slice().sort((a,b)=>a.id-b.id);return sorted[room.turnPlayerIdx%sorted.length].id;}
function applyMarketDelta(price,deltaRate){const next=Math.max(1,Math.round(Number(price)*(1+deltaRate)));return BigInt(next);}
function getTradeSnapshot(roomId,userId,market){const existing=tradeLockByRoom.get(roomId);if(!existing||existing.userId!==userId){const snapshot={samsung:market.priceSamsung,tesla:market.priceTesla,lockheed:market.priceLockheed,gold:market.priceGold,bitcoin:market.priceBtc};tradeLockByRoom.set(roomId,{userId,prices:snapshot});return snapshot;}return existing.prices;}
async function autoSellAssets(tx,player,amount,market){if(player.cash>=amount)return{player,autoSales:[],covered:true};const assets=player.assets||await tx.playerAsset.create({data:{playerId:player.id}});const sellOrder=[{key:"bitcoin",price:market.priceBtc},{key:"gold",price:market.priceGold},{key:"samsung",price:market.priceSamsung},{key:"tesla",price:market.priceTesla},{key:"lockheed",price:market.priceLockheed}];let updatedPlayer=player;let updatedAssets=assets;const autoSales=[];for(const item of sellOrder){if(updatedPlayer.cash>=amount)break;const owned=updatedAssets[item.key]||0;if(owned<=0)continue;const remaining=amount-updatedPlayer.cash;const price=item.price;const needed=(remaining+price-1n)/price;const sellQty=Math.min(owned,Number(needed));if(sellQty<=0)continue;const proceeds=price*BigInt(sellQty);updatedAssets=await tx.playerAsset.update({where:{playerId:player.id},data:{[item.key]:owned-sellQty}});updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:updatedPlayer.cash+proceeds}});autoSales.push({symbol:item.key,quantity:sellQty,price,proceeds});}const covered=updatedPlayer.cash>=amount;if(!covered){updatedPlayer=await tx.player.update({where:{id:player.id},data:{isBankrupt:true}});}return{player:updatedPlayer,autoSales,covered};}
const landVisitCount=new Map();
const landLastAction=new Map();
function getLandKey(playerId,nodeIdx){return `${playerId}:${nodeIdx}`;}
function getVisitCount(playerId,nodeIdx){return landVisitCount.get(getLandKey(playerId,nodeIdx))||0;}
function setVisitCount(playerId,nodeIdx,count){landVisitCount.set(getLandKey(playerId,nodeIdx),count);}
function incrementVisit(playerId,nodeIdx){setVisitCount(playerId,nodeIdx,getVisitCount(playerId,nodeIdx)+1);}
function getLastAction(playerId,nodeIdx){return landLastAction.get(getLandKey(playerId,nodeIdx))||null;}
function setLastAction(playerId,nodeIdx,action){landLastAction.set(getLandKey(playerId,nodeIdx),action);}
function getLineIndex(nodeIdx){return WAR_LINE_RANGES.findIndex((range)=>nodeIdx>=range.start&&nodeIdx<=range.end);}
function getAdjacentLines(lineIdx){const adjacent=[];if(lineIdx>0)adjacent.push(lineIdx-1);if(lineIdx<WAR_LINE_RANGES.length-1)adjacent.push(lineIdx+1);return adjacent;}
function getWarLandMultiplier(nodeIdx,isOwned){if(NEUTRAL_NODES.has(nodeIdx)||!isOwned)return 1;const lineIdx=getLineIndex(nodeIdx);if(warState.active){if(nodeIdx===warState.warNode)return 0.5;if(lineIdx===warState.warLine)return 0.75;return 1.1;}if(warState.recoveryActive&&lineIdx===warState.warLine){return nodeIdx===warState.warNode?warState.recoveryNode:warState.recoveryLine;}return 1;}
function applyWarMultiplier(value,nodeIdx,isOwned){const mult=getWarLandMultiplier(nodeIdx,isOwned);return BigInt(Math.round(Number(value)*mult));}
function getWarPayload(){return{active:warState.active,warLine:warState.warLine,warNode:warState.warNode,turnsLeft:warState.turnsLeft,recoveryActive:warState.recoveryActive,recoveryLine:warState.recoveryLine,recoveryNode:warState.recoveryNode,adjacentLines:warState.warLine!=null?getAdjacentLines(warState.warLine):[]};}
function getLobbyState(roomId){if(!lobbyStateByRoom.has(roomId))lobbyStateByRoom.set(roomId,{hostUserId:null,readyUserIds:new Set(),players:new Map()});return lobbyStateByRoom.get(roomId);}
function buildLobbyPayload(roomId){const lobby=getLobbyState(roomId);const players=Array.from(lobby.players.values()).map((p)=>({userId:p.userId,playerId:p.playerId,nickname:p.nickname||`Player${p.userId}`,character:p.character||null,ready:lobby.readyUserIds.has(p.userId),isHost:lobby.hostUserId===p.userId}));const allReady=players.filter((p)=>!p.isHost).every((p)=>p.ready);return{hostUserId:lobby.hostUserId,players,allReady};}
function shuffleArray(arr){for(let i=arr.length-1;i>0;i-=1){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;}
async function destroyMostExpensiveLandmark(tx,playerId){const landmarks=await tx.gameLand.findMany({where:{ownerId:playerId,isLandmark:true},orderBy:{purchasePrice:"desc"}});if(landmarks.length===0)return null;const target=landmarks[0];return tx.gameLand.update({where:{id:target.id},data:{isLandmark:false}});}
function getLandBasePrice(nodeIdx){return LAND_PRICE_BY_NODE[nodeIdx]||0n;}
function getLandBaseToll(nodeIdx,baseToll){return LAND_TOLL_BY_NODE[nodeIdx]||baseToll||0n;}
function calcLandPriceFromToll(baseToll,nodeIdx){const stability=LAND_STABILITY_BY_NODE[nodeIdx];const toll=getLandBaseToll(nodeIdx,baseToll);if(!stability||!toll)return getLandBasePrice(nodeIdx);return BigInt(Math.round(Number(toll)*7*stability));}
function getEffectiveLandPrice(baseToll,nodeIdx,isOwned){const basePrice=calcLandPriceFromToll(baseToll,nodeIdx);return applyWarMultiplier(basePrice,nodeIdx,isOwned);}
function clamp(value,min,max){return Math.max(min,Math.min(max,value));}
async function computeTotals(tx,playerId){const player=await tx.player.findUnique({where:{id:playerId},include:{assets:true,lands:true}});if(!player)throw new Error("Player not found");const market=await getOrCreateMarket(tx,player.roomId);const landTotal=player.lands.reduce((sum,land)=>sum+land.purchasePrice,0n);const assets=player.assets||{samsung:0,tesla:0,lockheed:0,gold:0,bitcoin:0};const stockTotal=BigInt(assets.samsung)*market.priceSamsung+BigInt(assets.tesla)*market.priceTesla+BigInt(assets.lockheed)*market.priceLockheed+BigInt(assets.gold)*market.priceGold+BigInt(assets.bitcoin)*market.priceBtc;const totalAsset=player.cash+landTotal+stockTotal;return{player,assets,market,landTotal,stockTotal,totalAsset};}
async function emitAssetUpdate(playerId){if(!io)return;try{const payload=await prisma.$transaction(async(tx)=>{const totals=await computeTotals(tx,playerId);await tx.player.update({where:{id:playerId},data:{totalAsset:totals.totalAsset}});return{roomId:totals.player.roomId,userId:totals.player.userId,cash:totals.player.cash,totalAsset:totals.totalAsset};});io.to(payload.roomId).emit("asset_update",payload);}catch(e){}}
function calcWarAssetValue(assets,market,cash){const stockValue=BigInt(assets.samsung)*market.priceSamsung+BigInt(assets.tesla)*market.priceTesla+BigInt(assets.lockheed)*market.priceLockheed;const goldValue=BigInt(assets.gold)*market.priceGold;const coinValue=BigInt(assets.bitcoin)*market.priceBtc;const weightedStock=Number(stockValue)*STOCK_WAR_WEIGHT.stock;const weightedGold=Number(goldValue)*STOCK_WAR_WEIGHT.gold;const weightedCoin=Number(coinValue)*STOCK_WAR_WEIGHT.bitcoin;return Number(cash)+weightedStock+weightedGold+weightedCoin;}
function calcWarWinRate({myAsset,oppAsset,character}){const ratio=myAsset+oppAsset===0?0.5:myAsset/(myAsset+oppAsset);const baseRaw=WAR_BASE_RATE+(ratio*WAR_RATIO_RATE);const base=clamp(baseRaw, WAR_BASE_MIN, WAR_BASE_MAX);const characterBonus=character===CHARACTER_LABEL.PUTIN?PUTIN_WAR_BONUS:0;return clamp(base+characterBonus, WAR_FINAL_MIN, WAR_FINAL_MAX);}
function applyTrumpBonus(toll,ownerCharacter){if(ownerCharacter!==CHARACTER_LABEL.TRUMP)return toll;return BigInt(Math.round(Number(toll)*(1+TRUMP_TOLL_BONUS_RATE)));}
async function rollDiceForUser({userId}){return prisma.$transaction(async(tx)=>{const player=await tx.player.findFirst({where:{userId},orderBy:{id:"desc"}});if(!player)throw new Error("Player not found");const room=await tx.room.findUnique({where:{id:player.roomId}});if(!room||room.status!=="PLAYING")throw new Error("Game not started");const currentTurnId=await getTurnPlayerId(tx,player.roomId);if(currentTurnId!==player.id)throw new Error("Not your turn");const turnState=turnStateByRoom.get(player.roomId)||{userId:player.userId,rolled:false,extraRoll:false};if(turnState.userId!==player.userId){turnState.userId=player.userId;turnState.rolled=false;turnState.extraRoll=false;}if(turnState.rolled&&!turnState.extraRoll)throw new Error("Already rolled");const dice1=Math.floor(Math.random()*6)+1;const dice2=Math.floor(Math.random()*6)+1;const isDouble=dice1===dice2;const oldLocation=player.location;const newLocation=(oldLocation+dice1+dice2)%32;const passedStart=newLocation<oldLocation;const salary=passedStart?200000n:0n;const hasExtraTurn=isDouble&&!player.extraTurnUsed;const currentMarket=await getOrCreateMarket(tx,player.roomId);const driftUpdates={};Object.values(MARKET_SYMBOLS).forEach((cfg)=>{const drift=(Math.random()*0.1)-0.05;driftUpdates[cfg.prevField]=currentMarket[cfg.priceField];driftUpdates[cfg.priceField]=applyMarketDelta(currentMarket[cfg.priceField],drift);});let market=await tx.market.update({where:{roomId:player.roomId},data:driftUpdates});let updatedPlayer=await tx.player.update({where:{id:player.id},data:{location:newLocation,cash:player.cash+salary,extraTurnUsed:hasExtraTurn?true:false}});turnState.rolled=true;turnState.extraRoll=hasExtraTurn;turnStateByRoom.set(player.roomId,turnState);actionWindowByRoom.set(player.roomId,{userId:player.userId,location:newLocation});let cardEvent=null;let tollOwnerId=null;let warStarted=false;let warEnded=false;const keyTiles=[12,20,28];if(keyTiles.includes(newLocation)){const cards=[{title:"\uC0DD\uC77C \uCD95\uD558\uAE08",description:"+100,000\uC6D0 \uC9C0\uAE09",amount:100000n},{title:"\uC138\uAE08 \uB0A9\uBD80",description:"-50,000\uC6D0 \uB0A9\uBD80",amount:-50000n},{title:"\uBCF5\uAD8C \uB2F9\uCCA8",description:"+200,000\uC6D0 \uB2F9\uCCA8",amount:200000n},{title:"\uAD50\uD1B5 \uBC94\uCE59\uAE08",description:"-30,000\uC6D0 \uB0A9\uBD80",amount:-30000n},{title:"\uBC30\uB2F9\uAE08 \uC218\uB839",description:"+150,000\uC6D0 \uC218\uB839",amount:150000n}];const lastIdx=lastCardByRoom.get(player.roomId);let idx=Math.floor(Math.random()*cards.length);if(cards.length>1&&idx===lastIdx)idx=(idx+1)%cards.length;lastCardByRoom.set(player.roomId,idx);const picked=cards[idx];const nextCash=updatedPlayer.cash+picked.amount;updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:nextCash}});cardEvent={title:picked.title,description:picked.description,amount:picked.amount,location:newLocation,playerId:player.id,userId:player.userId,cash:updatedPlayer.cash};const symbols=Object.keys(MARKET_SYMBOLS);const target=symbols[Math.floor(Math.random()*symbols.length)];const cfg=MARKET_SYMBOLS[target];const eventDelta=picked.amount>=0n?0.02:-0.02;const nextPrice=applyMarketDelta(market[cfg.priceField],eventDelta);market=await tx.market.update({where:{roomId:player.roomId},data:{[cfg.prevField]:market[cfg.priceField],[cfg.priceField]:nextPrice}});}if(newLocation===8&&!warState.active){const playerCount=await tx.player.count({where:{roomId:player.roomId}});warState.active=true;warState.warLine=getLineIndex(newLocation);warState.warNode=newLocation;warState.turnsLeft=playerCount;warState.recoveryActive=false;warState.recoveryLine=0.75;warState.recoveryNode=0.5;warStarted=true;}let autoSellEvents=[];if(newLocation===30){const totals=await computeTotals(tx,updatedPlayer.id);const tax=totals.totalAsset/10n;const sold=await autoSellAssets(tx,updatedPlayer,tax,market);updatedPlayer=sold.player;const payAmount=updatedPlayer.cash<tax?updatedPlayer.cash:tax;updatedPlayer=await tx.player.update({where:{id:updatedPlayer.id},data:{cash:updatedPlayer.cash-payAmount}});if(sold.autoSales.length)autoSellEvents.push({type:"TAX",items:sold.autoSales,amount:tax,paid:payAmount,bankrupt:!sold.covered});}const mapNode=await tx.mapNode.findUnique({where:{nodeIdx:newLocation}});if(mapNode?.type==="LAND"){const land=await tx.gameLand.findFirst({where:{roomId:updatedPlayer.roomId,nodeIdx:newLocation}});if(land&&land.ownerId===updatedPlayer.id){incrementVisit(updatedPlayer.id,newLocation);}else if(land&&land.ownerId&&land.ownerId!==updatedPlayer.id){const owner=await tx.player.findUnique({where:{id:land.ownerId}});if(owner){let toll=getLandBaseToll(newLocation,mapNode.baseToll);toll=applyTrumpBonus(toll,owner.character);toll=applyWarMultiplier(toll,newLocation,true);const sold=await autoSellAssets(tx,updatedPlayer,toll,market);updatedPlayer=sold.player;const payAmount=updatedPlayer.cash<toll?updatedPlayer.cash:toll;updatedPlayer=await tx.player.update({where:{id:updatedPlayer.id},data:{cash:updatedPlayer.cash-payAmount}});await tx.player.update({where:{id:owner.id},data:{cash:owner.cash+payAmount}});tollOwnerId=owner.id;if(sold.autoSales.length)autoSellEvents.push({type:"TOLL",items:sold.autoSales,amount:toll,paid:payAmount,bankrupt:!sold.covered,ownerId:owner.id});}}}const turnPlayerId=await getTurnPlayerId(tx,updatedPlayer.roomId);const turnUserId=currentTurnUserByRoom.get(updatedPlayer.roomId)||player.userId;return{dice1,dice2,isDouble,hasExtraTurn,oldLocation,newLocation,passedStart,player:updatedPlayer,roomId:updatedPlayer.roomId,cardEvent,tollOwnerId,turnPlayerId,turnUserId,market,war:getWarPayload(),warStarted,warEnded,autoSellEvents};});}
app.get("/auth/google",passport.authenticate("google",{scope:["profile","email"]}));
app.get("/api/auth/google/callback",passport.authenticate("google",{failureRedirect:"/"}),async(req,res)=>{try{if(req.user?.id){await prisma.$transaction(async(tx)=>{await tx.gameLand.updateMany({data:{ownerId:null}});await tx.player.updateMany({where:{userId:req.user.id},data:{cash:INITIAL_CASH,totalAsset:INITIAL_CASH,location:0,isBankrupt:false,extraTurnUsed:false}});});}return res.redirect("/");}catch(e){return res.redirect("/");}});
app.get("/api/auth/logout",(req,res)=>{req.logout((err)=>{if(err)return res.status(500).json({error:"Logout failed"});const cookieName="connect.sid";if(req.session){req.session.destroy(()=>{res.clearCookie(cookieName);res.redirect("/");});return;}res.clearCookie(cookieName);res.redirect("/");});});
app.get("/",(req,res)=>res.sendFile(path.join(__dirname,"public","index.html")));
app.get("/api/me",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const result=await prisma.$transaction(async(tx)=>{const player=await tx.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"}});if(!player)return{cash:0,location:0};const totals=await computeTotals(tx,player.id);return{cash:totals.player.cash,location:totals.player.location,totalAsset:totals.totalAsset,character:totals.player.character,userId:totals.player.userId,playerId:totals.player.id};});return res.json(result);}catch(e){return res.status(500).json({error:"Failed to load user"});}});
app.get("/api/map",async(req,res)=>{try{const mapData=await prisma.mapNode.findMany({include:{gameLands:{where:{roomId:1}}},orderBy:{nodeIdx:"asc"}});const normalized=mapData.map((node)=>{if(node.type!=="LAND")return node;const basePrice=getLandBasePrice(node.nodeIdx);return{...node,basePrice};});res.json(normalized);}catch(e){res.status(500).json({error:"Map load failed"});}});
app.get("/api/market",async(req,res)=>{try{const market=await prisma.$transaction(async(tx)=>getOrCreateMarket(tx,1));return res.json({samsung:market.priceSamsung,tesla:market.priceTesla,lockheed:market.priceLockheed,gold:market.priceGold,bitcoin:market.priceBtc});}catch(e){return res.status(500).json({error:"Failed to load market"});}});
app.post("/api/game/stock/sell",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const {stockName,quantity}=req.body||{};const norm=normalizeSymbol(stockName);const qty=Number(quantity);if(!norm||!Number.isInteger(qty)||qty<=0)return res.status(400).json({error:"Invalid request"});const result=await prisma.$transaction(async(tx)=>{const player=await tx.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"},include:{assets:true}});if(!player)throw new Error("Player not found");const currentTurn=currentTurnUserByRoom.get(player.roomId);if(currentTurn&&currentTurn!==player.userId)throw new Error("Not your turn");const actionWindow=actionWindowByRoom.get(player.roomId);if(!actionWindow||actionWindow.userId!==player.userId||actionWindow.location!==player.location)throw new Error("Action window closed");const market=await getOrCreateMarket(tx,player.roomId);const snapshot=getTradeSnapshot(player.roomId,player.userId,market);const priceKey=MARKET_SYMBOLS[norm].key;const price=snapshot[priceKey];const total=price*BigInt(qty);const assets=player.assets||await tx.playerAsset.create({data:{playerId:player.id}});const currentQty=assets[priceKey];if(currentQty<qty)throw new Error("Insufficient assets");const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:player.cash+total}});const updatedAssets=await tx.playerAsset.update({where:{playerId:player.id},data:{[priceKey]:currentQty-qty}});return{playerId:player.id,roomId:player.roomId,cash:updatedPlayer.cash,assets:updatedAssets,price,quantity:qty,type:"SELL",symbol:norm,market};});await emitAssetUpdate(result.playerId);return res.json(result);}catch(e){const message=e?.message==="Insufficient assets"||e?.message==="Player not found"||e?.message==="Not your turn"?e.message:"Failed to sell stock";return res.status(400).json({error:message});}});
app.post("/api/game/stock",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const {symbol,quantity,type}=req.body||{};const norm=normalizeSymbol(symbol);const qty=Number(quantity);const action=String(type||"").toUpperCase();if(!norm||!Number.isInteger(qty)||qty<=0||(action!=="BUY"&&action!=="SELL"))return res.status(400).json({error:"Invalid request"});const result=await prisma.$transaction(async(tx)=>{const player=await tx.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"},include:{assets:true}});if(!player)throw new Error("Player not found");const currentTurn=currentTurnUserByRoom.get(player.roomId);if(currentTurn&&currentTurn!==player.userId)throw new Error("Not your turn");const actionWindow=actionWindowByRoom.get(player.roomId);if(!actionWindow||actionWindow.userId!==player.userId||actionWindow.location!==player.location)throw new Error("Action window closed");const market=await getOrCreateMarket(tx,player.roomId);const snapshot=getTradeSnapshot(player.roomId,player.userId,market);const priceKey=MARKET_SYMBOLS[norm].key;const price=snapshot[priceKey];const total=price*BigInt(qty);const assets=player.assets||await tx.playerAsset.create({data:{playerId:player.id}});const currentQty=assets[priceKey]; if(action==="BUY"){if(player.cash<total)throw new Error("Insufficient cash");const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:player.cash-total}});const updatedAssets=await tx.playerAsset.update({where:{playerId:player.id},data:{[priceKey]:currentQty+qty}});return{playerId:player.id,roomId:player.roomId,cash:updatedPlayer.cash,assets:updatedAssets,price,quantity:qty,type:action,symbol:norm,market};}if(currentQty<qty)throw new Error("Insufficient assets");const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:player.cash+total}});const updatedAssets=await tx.playerAsset.update({where:{playerId:player.id},data:{[priceKey]:currentQty-qty}});return{playerId:player.id,roomId:player.roomId,cash:updatedPlayer.cash,assets:updatedAssets,price,quantity:qty,type:action,symbol:norm,market};});await emitAssetUpdate(result.playerId);return res.json(result);}catch(e){const message=e?.message==="Insufficient cash"||e?.message==="Insufficient assets"||e?.message==="Player not found"||e?.message==="Not your turn"?e.message:"Failed to trade stock";return res.status(400).json({error:message});}});
app.get("/api/players/:id/assets",async(req,res)=>{try{const userId=Number(req.params.id);if(!Number.isInteger(userId))return res.status(400).json({error:"Invalid user id"});const result=await prisma.$transaction(async(tx)=>{const player=await tx.player.findFirst({where:{userId},orderBy:{id:"desc"}});if(!player)throw new Error("Player not found");const totals=await computeTotals(tx,player.id);return{cash:totals.player.cash,lands:totals.player.lands,assets:totals.assets,stockTotal:totals.stockTotal,landTotal:totals.landTotal,totalAsset:totals.totalAsset};});return res.json(result);}catch(e){const message=e?.message==="Player not found"?e.message:"Failed to load assets";return res.status(404).json({error:message});}});
app.get("/api/users/profile",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const user=await prisma.user.findUnique({where:{id:req.user.id},select:{nickname:true,totalWins:true,totalGames:true}});if(!user)return res.status(404).json({error:"User not found"});const winRate=user.totalGames===0?0:Math.round((user.totalWins/user.totalGames)*10000)/10000;return res.json({nickname:user.nickname,totalWins:user.totalWins,totalGames:user.totalGames,winRate});}catch(e){return res.status(500).json({error:"Failed to load profile"});}});
app.post("/api/game/character",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const character=String(req.body?.character||"").toUpperCase();if(!CHARACTER_LABEL[character])return res.status(400).json({error:"Invalid character"});const result=await prisma.$transaction(async(tx)=>{const player=await tx.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"},include:{assets:true,room:true}});if(!player)throw new Error("Player not found");if(player.room?.status!=="WAITING")throw new Error("Game already started");const lobby=getLobbyState(player.roomId);const activeUserIds=new Set(lobby?.players?Array.from(lobby.players.keys()):[]);const others=await getLatestPlayersByUser(tx,player.roomId);const filtered=activeUserIds.size?others.filter((p)=>activeUserIds.has(p.userId)):others;if(filtered.some((p)=>p.userId!==player.userId&&p.character===character))throw new Error("Character already taken");let cash=INITIAL_CASH;let assets=player.assets||await tx.playerAsset.create({data:{playerId:player.id}});assets=await tx.playerAsset.update({where:{playerId:player.id},data:{samsung:0,tesla:0,lockheed:0,gold:0,bitcoin:0}});if(character===CHARACTER_LABEL.MUSK)cash+=MUSK_BONUS;if(character===CHARACTER_LABEL.LEE){assets=await tx.playerAsset.update({where:{playerId:player.id},data:{samsung:LEE_START_SAMSUNG_SHARES}});}const updated=await tx.player.update({where:{id:player.id},data:{character,cash,totalAsset:cash,location:0,extraTurnUsed:false}});return{playerId:player.id,character:updated.character,cash:updated.cash,roomId:player.roomId,userId:player.userId};});await emitAssetUpdate(result.playerId);if(io)io.to(result.roomId).emit("character_update",{playerId:result.playerId,userId:result.userId,character:result.character});return res.json({playerId:result.playerId,character:result.character,cash:result.cash});}catch(e){const message=e?.message||"Failed to set character";return res.status(400).json({error:message});}});
app.post("/api/game/worldcup",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const targetNodeIdx=Number(req.body?.nodeIdx);if(!Number.isInteger(targetNodeIdx))return res.status(400).json({error:"Invalid node"});const result=await prisma.$transaction(async(tx)=>{const host=await tx.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"}});if(!host)throw new Error("Player not found");if(host.location!==16)throw new Error("Not on EXPO");if(host.cash<WORLD_CUP_COST)throw new Error("Insufficient cash");const hostLand=await tx.gameLand.findFirst({where:{roomId:host.roomId,nodeIdx:targetNodeIdx,ownerId:host.id}});if(!hostLand)throw new Error("Land not owned");const mapNode=await tx.mapNode.findUnique({where:{nodeIdx:targetNodeIdx}});if(!mapNode||mapNode.type!=="LAND")throw new Error("Invalid land");const updatedHost=await tx.player.update({where:{id:host.id},data:{cash:host.cash-WORLD_CUP_COST}});const players=await tx.player.findMany({where:{roomId:host.roomId}});const tollBase=getLandBaseToll(targetNodeIdx,mapNode.baseToll);const hostToll=applyWarMultiplier(applyTrumpBonus(tollBase,updatedHost.character),targetNodeIdx,true);for(const p of players){const movingData={location:targetNodeIdx};if(p.id!==updatedHost.id){const cash=p.cash-hostToll;await tx.player.update({where:{id:p.id},data:{...movingData,cash}});await tx.player.update({where:{id:updatedHost.id},data:{cash:updatedHost.cash+hostToll}});updatedHost.cash+=hostToll;}else{await tx.player.update({where:{id:p.id},data:movingData});}}return{roomId:host.roomId,hostId:host.id,nodeIdx:targetNodeIdx};});const roomPlayers=await prisma.player.findMany({where:{roomId:result.roomId},select:{id:true}});for(const p of roomPlayers){await emitAssetUpdate(p.id);}io.to(result.roomId).emit("worldcup",{hostId:result.hostId,nodeIdx:result.nodeIdx});return res.json(result);}catch(e){const message=e?.message||"Failed to host worldcup";return res.status(400).json({error:message});}});
app.post("/api/game/war/lose",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const loserUserId=Number(req.body?.loserUserId);if(!Number.isInteger(loserUserId))return res.status(400).json({error:"Invalid loser"});const result=await prisma.$transaction(async(tx)=>{const loser=await tx.player.findFirst({where:{userId:loserUserId},orderBy:{id:"desc"}});if(!loser)throw new Error("Player not found");const destroyed=await destroyMostExpensiveLandmark(tx,loser.id);return{roomId:loser.roomId,loserId:loser.id,destroyed};});if(result.destroyed){io.to(result.roomId).emit("landmark_destroyed",{loserId:result.loserId,landId:result.destroyed.id});}return res.json({ok:true});}catch(e){const message=e?.message||"Failed to process war loss";return res.status(400).json({error:message});}});
app.post("/api/game/war-rate",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const opponentUserId=Number(req.body?.opponentUserId);if(!Number.isInteger(opponentUserId))return res.status(400).json({error:"Invalid opponent"});const result=await prisma.$transaction(async(tx)=>{const me=await tx.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"},include:{assets:true}});const opp=await tx.player.findFirst({where:{userId:opponentUserId},orderBy:{id:"desc"},include:{assets:true}});if(!me||!opp)throw new Error("Player not found");const market=await getOrCreateMarket(tx,me.roomId);const myAsset=calcWarAssetValue(me.assets||{samsung:0,tesla:0,lockheed:0,gold:0,bitcoin:0},market,me.cash);const oppAsset=calcWarAssetValue(opp.assets||{samsung:0,tesla:0,lockheed:0,gold:0,bitcoin:0},market,opp.cash);const winRate=calcWarWinRate({myAsset,oppAsset,character:me.character});return{myAsset,oppAsset,winRate};});return res.json(result);}catch(e){const message=e?.message||"Failed to calc war rate";return res.status(400).json({error:message});}});
app.get("/api/test/roll",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const result=await rollDiceForUser({userId:req.user.id});return res.json(result);}catch(e){return res.status(500).json({error:"Failed to roll dice"});}});
app.get("/api/bigint-test",(req,res)=>{res.json({cash:INITIAL_CASH,totalAsset:INITIAL_CASH});});
app.post("/api/game/purchase",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const action=String(req.body?.action||"BUY").toUpperCase();const player=await prisma.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"}});if(!player)return res.status(404).json({error:"Player not found"});const targetNodeIdx=Number.isInteger(Number(req.body?.nodeIdx))?Number(req.body.nodeIdx):player.location;const isRemote=targetNodeIdx!==player.location; if(isRemote&&player.location!==0)return res.status(400).json({error:"Remote action not allowed"});const mapNode=await prisma.mapNode.findUnique({where:{nodeIdx:targetNodeIdx}});if(!mapNode||mapNode.type!=="LAND")return res.status(400).json({error:`Invalid tile type: ${mapNode?.type||"UNKNOWN"}`});const result=await prisma.$transaction(async(tx)=>{const freshPlayer=await tx.player.findUnique({where:{id:player.id}});if(!freshPlayer)throw new Error("Player not found");const currentTurn=currentTurnUserByRoom.get(player.roomId);if(currentTurn&&currentTurn!==player.userId)throw new Error("Not your turn");const actionWindow=actionWindowByRoom.get(player.roomId);if(!actionWindow||actionWindow.userId!==player.userId||actionWindow.location!==player.location)throw new Error("Action window closed");const freshLand=await tx.gameLand.findFirst({where:{roomId:player.roomId,nodeIdx:targetNodeIdx}});const visitCount=getVisitCount(player.id,targetNodeIdx);const lastAction=getLastAction(player.id,targetNodeIdx);const canUpgrade=visitCount>0&&lastAction!=="BUY"&&lastAction!=="TAKEOVER";if(action==="BUY"){if(isRemote)throw new Error("Remote action not allowed");if(freshLand&&freshLand.ownerId!=null)throw new Error("Land already owned");const landPrice=getEffectiveLandPrice(mapNode.baseToll,targetNodeIdx,false);if(freshPlayer.cash<landPrice)throw new Error("Insufficient cash");const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:freshPlayer.cash-landPrice}});if(freshLand){await tx.gameLand.update({where:{id:freshLand.id},data:{ownerId:player.id,isLandmark:false,purchasePrice:landPrice}});}else{await tx.gameLand.create({data:{roomId:player.roomId,nodeIdx:targetNodeIdx,ownerId:player.id,purchasePrice:landPrice}});}setVisitCount(player.id,targetNodeIdx,0);setLastAction(player.id,targetNodeIdx,"BUY");return{playerId:player.id,cash:updatedPlayer.cash,nodeIdx:targetNodeIdx,action};}if(action==="TAKEOVER"){if(isRemote)throw new Error("Remote action not allowed");if(!freshLand||!freshLand.ownerId||freshLand.ownerId===player.id)throw new Error("Invalid takeover");if(freshLand.isLandmark)throw new Error("Landmark protected");const landPrice=getEffectiveLandPrice(mapNode.baseToll,targetNodeIdx,true);const takeoverCost=landPrice*TAKEOVER_RATE_NUM/TAKEOVER_RATE_DEN;if(freshPlayer.cash<takeoverCost)throw new Error("Insufficient cash");const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:freshPlayer.cash-takeoverCost}});await tx.gameLand.update({where:{id:freshLand.id},data:{ownerId:player.id,isLandmark:false,purchasePrice:takeoverCost}});setVisitCount(player.id,targetNodeIdx,0);setLastAction(player.id,targetNodeIdx,"TAKEOVER");return{playerId:player.id,cash:updatedPlayer.cash,nodeIdx:targetNodeIdx,action,cost:takeoverCost};}if(action==="LANDMARK"){if(!freshLand||freshLand.ownerId!==player.id)throw new Error("Not your land");if(freshLand.isLandmark)throw new Error("Already landmark");if(!canUpgrade)throw new Error("Revisit required");const landPrice=getEffectiveLandPrice(mapNode.baseToll,targetNodeIdx,true);const buildCost=landPrice*LANDMARK_RATE_NUM/LANDMARK_RATE_DEN;if(freshPlayer.cash<buildCost)throw new Error("Insufficient cash");const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:freshPlayer.cash-buildCost}});await tx.gameLand.update({where:{id:freshLand.id},data:{isLandmark:true,purchasePrice:freshLand.purchasePrice+buildCost}});setLastAction(player.id,targetNodeIdx,"LANDMARK");return{playerId:player.id,cash:updatedPlayer.cash,nodeIdx:targetNodeIdx,action,cost:buildCost};}if(action==="SELL"){if(!freshLand||freshLand.ownerId!==player.id)throw new Error("Not your land");if(!canUpgrade)throw new Error("Revisit required");const refund=freshLand.purchasePrice*SELL_RATE_NUM/SELL_RATE_DEN;const updatedPlayer=await tx.player.update({where:{id:player.id},data:{cash:freshPlayer.cash+refund}});await tx.gameLand.update({where:{id:freshLand.id},data:{ownerId:null,isLandmark:false,purchasePrice:0}});setLastAction(player.id,targetNodeIdx,"SELL");return{playerId:player.id,cash:updatedPlayer.cash,nodeIdx:targetNodeIdx,action,refund};}throw new Error("Invalid action");});await emitAssetUpdate(result.playerId);return res.json(result);}catch(e){const message=e?.message||"Failed to purchase land";return res.status(400).json({error:message});}});
app.get("/api/test/purchase-cheat",async(req,res)=>{try{if(!req.isAuthenticated||!req.isAuthenticated())return res.status(401).json({error:"Unauthorized"});const player=await prisma.player.findFirst({where:{userId:req.user.id},orderBy:{id:"desc"}});if(!player)return res.status(404).json({error:"Player not found"});const mapNode=await prisma.mapNode.findUnique({where:{nodeIdx:player.location}});if(!mapNode)return res.status(404).json({error:"Map node not found"});const land=await prisma.gameLand.findFirst({where:{roomId:player.roomId,nodeIdx:player.location}});if(land){await prisma.gameLand.update({where:{id:land.id},data:{ownerId:null}});}else{await prisma.gameLand.create({data:{roomId:player.roomId,nodeIdx:player.location,ownerId:null}});}return res.json({ok:true,nodeIdx:player.location});}catch(e){return res.status(500).json({error:"Failed to clear land owner"});}});
app.get("/api/test/reset-lands",async(req,res)=>{try{await prisma.gameLand.deleteMany();return res.json({ok:true});}catch(e){return res.status(500).json({error:"Failed to reset lands"});}});
io=new Server(server,{cors:{origin:"*"}});
io.use((socket,next)=>{sessionMiddleware(socket.request,{},()=>{passport.initialize()(socket.request,{},()=>{passport.session()(socket.request,{},next);});});});
io.on("connection",(socket)=>{console.log(`User connected: ${socket.id}`);socket.on("join_room",async(roomId)=>{try{const sessionUserId=socket.request.session?.userId||socket.request.session?.passport?.user?.id||socket.request.user?.id;if(!sessionUserId){socket.emit("join_error",{message:"User session not found"});return;}let room=await prisma.room.findUnique({where:{id:roomId}});if(!room){socket.emit("join_error",{message:"Room not found"});return;}const lobbyState=getLobbyState(roomId);if(room.status!=="WAITING"&&lobbyState.players.size===0){room=await prisma.room.update({where:{id:roomId},data:{status:"WAITING",turnPlayerIdx:0,currentTurn:1}});currentTurnUserByRoom.delete(roomId);roomTurnOrder.delete(roomId);tradeLockByRoom.delete(roomId);actionWindowByRoom.delete(roomId);turnStateByRoom.delete(roomId);lastCardByRoom.delete(roomId);}if(room.status==="PLAYING"&&!roomTurnOrder.get(roomId)){room=await prisma.room.update({where:{id:roomId},data:{status:"WAITING",turnPlayerIdx:0,currentTurn:1}});}const user=await prisma.user.findUnique({where:{id:sessionUserId}});let player=await prisma.player.findFirst({where:{roomId,userId:sessionUserId},orderBy:{id:"desc"},include:{assets:true}});if(!player){player=await prisma.player.create({data:{roomId,userId:sessionUserId,socketId:socket.id,cash:INITIAL_CASH,totalAsset:INITIAL_CASH,assets:{create:{samsung:0,tesla:0,lockheed:0,gold:0,bitcoin:0}}},include:{assets:true}});}else{player=await prisma.player.update({where:{id:player.id},data:{socketId:socket.id},include:{assets:true}});}if(room.status==="WAITING"&&player.character){player=await prisma.player.update({where:{id:player.id},data:{character:null},include:{assets:true}});}socket.join(roomId);socketUserMap.set(socket.id,{roomId,userId:sessionUserId});const lobby=getLobbyState(roomId);lobby.players.set(sessionUserId,{userId:sessionUserId,nickname:user?.nickname||user?.displayName||`Player${sessionUserId}`,playerId:player.id,character:player.character});if(!lobby.hostUserId)lobby.hostUserId=sessionUserId;const turnPlayerId=await prisma.$transaction(async(tx)=>getTurnPlayerId(tx,roomId));const market=await prisma.$transaction(async(tx)=>getOrCreateMarket(tx,roomId));socket.emit("join_success",{roomId,message:"Join success",player,turnPlayerId,war:getWarPayload(),roomStatus:room.status,lobby:buildLobbyPayload(roomId),currentTurn:currentTurnUserByRoom.get(roomId)||null});socket.emit("market_update",{samsung:market.priceSamsung,tesla:market.priceTesla,lockheed:market.priceLockheed,gold:market.priceGold,bitcoin:market.priceBtc,prevSamsung:market.prevSamsung,prevTesla:market.prevTesla,prevLockheed:market.prevLockheed,prevGold:market.prevGold,prevBtc:market.prevBtc});socket.emit("war_state",getWarPayload());io.to(roomId).emit("lobby_update",buildLobbyPayload(roomId));await emitAssetUpdate(player.id);}catch(e){socket.emit("join_error",{message:"Failed to join room"});}});socket.on("set_ready",async({ready})=>{try{const info=socketUserMap.get(socket.id);if(!info)return;const lobby=getLobbyState(info.roomId);if(info.userId===lobby.hostUserId)return;const player=await prisma.player.findFirst({where:{userId:info.userId,roomId:info.roomId},orderBy:{id:"desc"}});const isReady=!!ready;if(isReady&&(!player||!player.character)){socket.emit("ready_error",{message:"Select a character before ready"});return;}if(isReady)lobby.readyUserIds.add(info.userId);else lobby.readyUserIds.delete(info.userId);if(player){const entry=lobby.players.get(info.userId);if(entry)entry.character=player.character||null;if(player.character)io.to(info.roomId).emit("character_update",{playerId:player.id,userId:info.userId,character:player.character});}io.to(info.roomId).emit("lobby_update",buildLobbyPayload(info.roomId));}catch(e){}});socket.on("end_turn",async()=>{try{const sessionUser=socket.request.user;const userId=sessionUser?.id||socket.request.session?.passport?.user?.id||socket.request.session?.userId;if(!userId){socket.emit("turn_error",{message:"Login session expired"});return;}const info=socketUserMap.get(socket.id);if(!info){socket.emit("turn_error",{message:"Room not joined"});return;}const currentTurn=currentTurnUserByRoom.get(info.roomId);if(currentTurn&&currentTurn!==userId){socket.emit("turn_error",{message:"Not your turn"});return;}const room=await prisma.room.findUnique({where:{id:info.roomId}});if(!room)throw new Error("Room not found");if(room.status!=="PLAYING")throw new Error("Game not started");const turnState=turnStateByRoom.get(info.roomId);if(!turnState||turnState.userId!==userId||!turnState.rolled||turnState.extraRoll)throw new Error("Roll extra turn before ending" );const order=roomTurnOrder.get(info.roomId);const players=order&&order.length?order:(await getLatestPlayersByUser(prisma,info.roomId)).map((p)=>p.id);if(players.length===0)throw new Error("Player count is zero");const nextIdx=(room.turnPlayerIdx+1)%players.length;await prisma.player.updateMany({where:{roomId:info.roomId,userId},data:{extraTurnUsed:false}});const nextTurnNumber=(room.currentTurn||1)+1;if(nextTurnNumber> (room.maxTurn||10)){const lobbyPlayers=getLobbyState(info.roomId).players;const activeUserIds=new Set(lobbyPlayers?Array.from(lobbyPlayers.keys()):[]);const latestPlayers=await getLatestPlayersByUser(prisma,info.roomId);const activePlayers=activeUserIds.size?latestPlayers.filter((p)=>activeUserIds.has(p.userId)):latestPlayers;const rankings=[];const users=await prisma.user.findMany({where:{id:{in:activePlayers.map((p)=>p.userId)}},select:{id:true,nickname:true}});const nickMap=new Map(users.map((u)=>[u.id,u.nickname]));for(const p of activePlayers){const totals=await prisma.$transaction(async(tx)=>computeTotals(tx,p.id));rankings.push({userId:p.userId,playerId:p.id,nickname:nickMap.get(p.userId)||`Player${p.userId}`,totalAsset:totals.totalAsset,cash:totals.player.cash});}rankings.sort((a,b)=>Number(b.totalAsset-a.totalAsset));await prisma.room.update({where:{id:info.roomId},data:{status:"ENDED",currentTurn:nextTurnNumber}});currentTurnUserByRoom.delete(info.roomId);tradeLockByRoom.delete(info.roomId);actionWindowByRoom.delete(info.roomId);turnStateByRoom.delete(info.roomId);io.to(info.roomId).emit("game_end",{rankings,maxTurn:room.maxTurn||10});return;}await prisma.room.update({where:{id:info.roomId},data:{turnPlayerIdx:nextIdx,currentTurn:nextTurnNumber}});const nextTurnPlayerId=await prisma.$transaction(async(tx)=>getTurnPlayerId(tx,info.roomId));let nextTurnUserId=null;if(nextTurnPlayerId){const p=await prisma.player.findUnique({where:{id:nextTurnPlayerId}});nextTurnUserId=p?.userId||null;}currentTurnUserByRoom.set(info.roomId,nextTurnUserId);tradeLockByRoom.delete(info.roomId);actionWindowByRoom.delete(info.roomId);turnStateByRoom.set(info.roomId,{userId:nextTurnUserId,rolled:false,extraRoll:false});if(warState.active){warState.turnsLeft-=1;if(warState.turnsLeft<=0){warState.active=false;warState.recoveryActive=true;}}else if(warState.recoveryActive){warState.recoveryLine=Math.min(1,Math.round((warState.recoveryLine+0.1)*100)/100);warState.recoveryNode=Math.min(1,Math.round((warState.recoveryNode+0.1)*100)/100);if(warState.recoveryLine>=1&&warState.recoveryNode>=1){warState.recoveryActive=false;warState.warLine=null;warState.warNode=null;}}io.to(info.roomId).emit("turn_update",{currentTurn:nextTurnUserId,turnPlayerId:nextTurnPlayerId,war:getWarPayload()});}catch(e){socket.emit("turn_error",{message:e?.message||"Failed to end turn"});}});socket.on("start_game",async()=>{try{const info=socketUserMap.get(socket.id);if(!info){socket.emit("start_error",{message:"Room not joined"});return;}const lobby=getLobbyState(info.roomId);if(lobby.hostUserId!==info.userId){socket.emit("start_error",{message:"Only host can start"});return;}const payload=buildLobbyPayload(info.roomId);if(!payload.allReady){socket.emit("start_error",{message:"All players must be ready"});return;}const lobbyPlayers=getLobbyState(info.roomId).players;const activeUserIds=new Set(lobbyPlayers?Array.from(lobbyPlayers.keys()):[]);const allPlayers=await getLatestPlayersByUser(prisma,info.roomId);const players=activeUserIds.size?allPlayers.filter((p)=>activeUserIds.has(p.userId)):allPlayers;if(players.length===0){socket.emit("start_error",{message:"No players"});return;}if(players.some((p)=>!p.character)){socket.emit("start_error",{message:"All players must select a character"});return;}const shuffled=shuffleArray(players.slice());const orderPlayerIds=shuffled.map((p)=>p.id);const orderUserIds=shuffled.map((p)=>p.userId);roomTurnOrder.set(info.roomId,orderPlayerIds);const currentTurn=orderUserIds[0]||null;currentTurnUserByRoom.set(info.roomId,currentTurn);tradeLockByRoom.delete(info.roomId);actionWindowByRoom.delete(info.roomId);turnStateByRoom.set(info.roomId,{userId:currentTurn,rolled:false,extraRoll:false});await prisma.room.update({where:{id:info.roomId},data:{status:"PLAYING",turnPlayerIdx:0,currentTurn:1}});await prisma.$transaction(async(tx)=>resetMarketDefaults(tx,info.roomId));const turnPlayerId=orderPlayerIds[0]||null;const lobbyInfo=buildLobbyPayload(info.roomId);const nicknameByUser=new Map(lobbyInfo.players.map((p)=>[p.userId,p.nickname]));const playersPayload=players.map((p)=>({playerId:p.id,userId:p.userId,nickname:nicknameByUser.get(p.userId)||`Player${p.userId}`,character:p.character||null,location:typeof p.location==="number"?p.location:0}));console.log(`[System] Game Started. Turn Order: [${orderUserIds.join(", ")}]`);io.to(info.roomId).emit("game_start",{turnPlayerId,currentTurn,turnOrder:orderUserIds,turnOrderPlayerIds:orderPlayerIds,players:playersPayload});io.to(info.roomId).emit("lobby_update",buildLobbyPayload(info.roomId));}catch(e){socket.emit("start_error",{message:"Failed to start game"});}});socket.on("roll_dice",async()=>{console.log("roll_dice received",socket.id);try{const sessionUser=socket.request.user;const userId=sessionUser?.id||socket.request.session?.passport?.user?.id||socket.request.session?.userId;if(!userId){socket.emit("roll_error",{message:"Login session expired"});console.log("emit failed: login session expired");return;}const result=await rollDiceForUser({userId});const userName=sessionUser?.nickname||sessionUser?.displayName||"Player";console.log(`[${userName}] moved ${result.oldLocation} -> ${result.newLocation}`);socket.emit("dice_rolled",{userId,dice1:result.dice1,dice2:result.dice2,isDouble:result.isDouble,hasExtraTurn:result.hasExtraTurn,passedStart:result.passedStart,player:result.player,turnPlayerId:result.turnPlayerId,turnUserId:result.turnUserId,autoSellEvents:result.autoSellEvents});io.to(result.roomId).emit("playerMove",{userId,playerId:result.player.id,character:result.player.character,oldLocation:result.oldLocation,newLocation:result.newLocation,dice1:result.dice1,dice2:result.dice2,isDouble:result.isDouble,hasExtraTurn:result.hasExtraTurn,passedStart:result.passedStart,turnPlayerId:result.turnPlayerId,turnUserId:result.turnUserId,autoSellEvents:result.autoSellEvents});if(result.cardEvent){io.to(result.roomId).emit("drawCard",result.cardEvent);}if(result.market){io.to(result.roomId).emit("market_update",{samsung:result.market.priceSamsung,tesla:result.market.priceTesla,lockheed:result.market.priceLockheed,gold:result.market.priceGold,bitcoin:result.market.priceBtc,prevSamsung:result.market.prevSamsung,prevTesla:result.market.prevTesla,prevLockheed:result.market.prevLockheed,prevGold:result.market.prevGold,prevBtc:result.market.prevBtc});}if(result.war){io.to(result.roomId).emit("war_state",result.war);if(result.warStarted){io.to(result.roomId).emit("war_start",result.war);}if(result.warEnded){io.to(result.roomId).emit("war_end",result.war);}}await emitAssetUpdate(result.player.id);if(result.tollOwnerId)await emitAssetUpdate(result.tollOwnerId);console.log("emit success: true");}catch(e){socket.emit("roll_error",{message:e?.message||"Failed to roll dice"});console.log("emit failed",e?.message||e);}});socket.on("disconnect",()=>{const info=socketUserMap.get(socket.id);if(!info)return;socketUserMap.delete(socket.id);const lobby=getLobbyState(info.roomId);lobby.players.delete(info.userId);lobby.readyUserIds.delete(info.userId);if(lobby.hostUserId===info.userId){const nextHost=lobby.players.keys().next();lobby.hostUserId=nextHost.done?null:nextHost.value;}if(lobby.players.size===0){lobbyStateByRoom.delete(info.roomId);roomTurnOrder.delete(info.roomId);return;}io.to(info.roomId).emit("lobby_update",buildLobbyPayload(info.roomId));});});
async function initGame(){try{const room=await prisma.room.findUnique({where:{id:1}});if(!room)await prisma.room.create({data:{id:1,roomCode:"DEMO",status:"WAITING"}});}catch(e){console.error(e);}}
server.listen(3000,async()=>{await initGame();console.log("Server running at http://localhost:3000");});











